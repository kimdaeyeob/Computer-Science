- [SCOPE](#scope)
  - [자바스크립트 엔진이 코드를 실행하는 단계](#자바스크립트-엔진이-코드를-실행하는-단계)
    - [1️⃣ 스코프 생성](#1️⃣-스코프-생성)
    - [2️⃣ 호이스팅 \& 섀도잉](#2️⃣-호이스팅--섀도잉)
    - [3️⃣ 초기화 이전 접근](#3️⃣-초기화-이전-접근)
- [핵심 개념](#핵심-개념)
  - [Lexical Scope](#lexical-scope)
    - [Lexical Scope가 생성되는 이유](#lexical-scope가-생성되는-이유)
    - [Lexical Scope가 미치는 영향](#lexical-scope가-미치는-영향)
      - [따라서](#따라서)
  - [Block Scope](#block-scope)
  - [호이스팅](#호이스팅)
    - [(호이스팅 심화) var, const, let](#호이스팅-심화-var-const-let)
  - [TDZ (Temporal Dead Zone)](#tdz-temporal-dead-zone)
- [코드 해석](#코드-해석)
- [심화 개념](#심화-개념)
  - [함수 레벨 스코프](#함수-레벨-스코프)

# SCOPE

```js
let num = 7;

if (1) {
  console.log(num);
  let num = 10;
}
```

- `모든 식별자(변수명, 함수명, 클래스명 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위`가 결정되는데, 이것을 스코프라 함

- 스코프(유효 범위)를 통해서 식별자의 충돌을 방지함

## 자바스크립트 엔진이 코드를 실행하는 단계

### 1️⃣ 스코프 생성

- if 블록안으로 진입하는 순간, JS는 이 블록을 위한 새로운 lexical scope를 생성

---

### 2️⃣ 호이스팅 & 섀도잉

엔진은 블록 내부를 훑어보고 `let num`이 있다는 것을 인지함.

이때 내부의 `num`은 외부의 `let num = 7`을 가려버림 (variable shadowing).

(즉, 블록 내부에서 `a`는 오직 내부 변수만을 가리키게 됨)

### 3️⃣ 초기화 이전 접근

`console.log(num)`이 실행되는 시점은 내부 변수 `num`이 선언(`let num`)되기 이전임

---

</br>

# 핵심 개념

## Lexical Scope

- `함수를 어디에서 정의했는지에 따라 함수의 상위 스코프를 결정`하는 방식 (= `static scope`, `정적 스코프`)<br/>
  -> 동적 스코프 방식처럼 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되므로 정적 스코프라고 부름.<br/>(JS를 비롯한 대부분의 프로그래밍 언어에서는 렉시컬 스코프를 따름)

- 코드를 작성할 때 결정되는 변수의 유효범위
  (코드가 어디서 실행되며 주변에 어떠한 코드가 있는지를 뜻함)

- 렉시컬 스코프는 `코드의 문맥`이라고 보면 되는데, 이를 구현한 것이 `execution context`임
  (모든 코드는 실행 컨텍스트에서 평가되고 실행됨)

```js
let num = 7;
if (1) {
  // ← 이 중괄호 { }가 새로운 블록을 만듦
  console.log(num);
  let num = 10;
}
```

### Lexical Scope가 생성되는 이유

- `{ }` 중괄호를 만나면 JS Engine은 자동으로 새로운 스코프를 생성한다.<br/>
  -> 이는 변수들을 격리시켜 관리하기 위함이다.

### Lexical Scope가 미치는 영향

- 자바스크립트가 렉시컬 스코프를 따르기 때문에 함수를 어디서 호출했는지가 아니라 함수를 어디에서 정의했는지에 따라 상위 스코프를 결정함 <br/> 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. (즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프이다.)

- 이처럼 함수의 상위 스코프는 함수의 정의가 실행될 때 정적(static)으로 결정된다. <br/>함수 정의(함수 선언문 또는 함수 표현식)가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다. (함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문임)

#### 따라서

- 내부 스코프는 외부 변수에서 접근 가능
- 외부 스코프는 내부 변수에 접근 불가능
- 같은 이름의 변수가 있다면 '가장 가까운 스코프'의 변수를 사용

## Block Scope

`let`과 `const`는 block level scope를 따른다.<br/>

중괄호 {}로 감싸진 영역(if문, for문 등) 안에서 선언된 변수는 그 블록 밖에서는 접근할 수 없으며, 반대로 블록 안에서는 독립적인 변수로 취급함.

## 호이스팅

변수 선언이 스코프 최상단으로 끌어올려진 것처럼 동작하는 것<br/>

- [Hoisting 개념 LINK](../hoisting/README.md)

### (호이스팅 심화) var, const, let

- _중요:_ `var`뿐만 아니라 `const`와 `let`도 호이스팅됨

- 다만, `var`와 달리 `let`은 `선언 단계`와 `초기화 단계`가 분리되어 있음<br/>

- 이해가 안가는 부분(하단)

스코프 진입 시 변수의 존재는 알지만(호이스팅 됨), 초기화 코드를 만날 때까지 메모리에 값을 할당하지 않습니다.

## TDZ (Temporal Dead Zone)

- `스코프의 시작 지점부터 변수 선언문이 나오기 전까지 구간`

- 이 구간에서 변수를 참고하려고 하면 `ReferenceError`가 발생함

- TDZ 진행 단계

1. 블록 진입(`{`): 내부 변수 `num`의 스코프가 시작됨 (TDZ 시작). 외부 변수 `num = 7`은 가려짐

2. `console.log(num)`: 아직 `num`이 초기화되지 않음 (TDZ 내부) -> `에러 발생!`

3. `let num = 10;`: 변수 `num`이 선언 및 초기화됨 (TDZ 종료)
   -> 이 줄 이후부터는 `num`을 안전하게 사용할 수 있음

# 코드 해석

```js
let num = 7; // 전역(혹은 상위)스코프의 num

if (true) {
  // <--- 여기부터 블록 스코프 시작
  // 엔진: "어? 밑에 'let num'이 있네? 이 블록에서 'num'는 내부 변수다. 호이스팅하자."
  // 엔진: "하지만 아직 초기화는 안 했으니 접근하면 에러를 낼 거야." (TDZ 시작)

  console.log(num); // [에러 발생!] TDZ 구간에서 num을 호출했음.
  // 외부의 num(7)가 아니라, 초기화되지 않은 내부 num을 참조하려다 실패.

  let num = 10; // <--- 여기서부터 TDZ 끝. 이제 num은 10임.
}
```

# 심화 개념

## 함수 레벨 스코프

- C, Java를 비롯하여 대부분의 프로그래밍 언어에서는 함수 몸체 내부 뿐만 아니라 조건문(if), 반복문(for, while), try/catch문 등 모든 코드 블록에서 지역 스코프를 만든다.

- 하지만 `var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정`하는데, 이러한 특성을 `함수 레벨 스코프 (function level scope)`라 한다.

```js
var x = 1;

if (true) {
  // 전역 변수로 취급 (중복 선언된 변수) > 의도치 않은 변경을 야기할 수 있음
  var x = 17;
}

console.log(x); // 17;
```

```js
var num = 7;

// for문 내에서 var는 전역변수임
for (var num = 0; num < 5; num++) {
  console.log(num); // 0 1 2 3 4
}

console.log(num); // 5
```
