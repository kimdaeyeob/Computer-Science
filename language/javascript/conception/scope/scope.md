- [SCOPE](#scope)
  - [자바스크립트 엔진이 코드를 실행하는 단계](#자바스크립트-엔진이-코드를-실행하는-단계)
    - [1️⃣ 스코프 생성](#1️⃣-스코프-생성)
    - [2️⃣ 호이스팅 \& 섀도잉](#2️⃣-호이스팅--섀도잉)
    - [3️⃣ 초기화 이전 접근](#3️⃣-초기화-이전-접근)
- [핵심 개념](#핵심-개념)
  - [Lexical Scope](#lexical-scope)
    - [Lexical Scope가 생성되는 이유](#lexical-scope가-생성되는-이유)
    - [Lexical Scope가 미치는 여향](#lexical-scope가-미치는-여향)
  - [Block Scope](#block-scope)
  - [호이스팅](#호이스팅)
    - [(호이스팅 심화) var, const, let](#호이스팅-심화-var-const-let)
  - [TDZ (Temporal Dead Zone)](#tdz-temporal-dead-zone)
- [코드 해석](#코드-해석)

# SCOPE

```js
let num = 7;

if (1) {
  console.log(num);
  let num = 10;
}
```

- `모든 식별자(변수명, 함수명, 클래스명 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위`가 결정되는데, 이것을 스코프라 함

- 스코프(유효 범위)를 통해서 식별자의 충돌을 방지함

## 자바스크립트 엔진이 코드를 실행하는 단계

### 1️⃣ 스코프 생성

- if 블록안으로 진입하는 순간, JS는 이 블록을 위한 새로운 lexical scope를 생성

---

### 2️⃣ 호이스팅 & 섀도잉

엔진은 블록 내부를 훑어보고 `let num`이 있다는 것을 인지함.

이때 내부의 `num`은 외부의 `let num = 7`을 가려버림 (variable shadowing).

(즉, 블록 내부에서 `a`는 오직 내부 변수만을 가리키게 됨)

### 3️⃣ 초기화 이전 접근

`console.log(num)`이 실행되는 시점은 내부 변수 `num`이 선언(`let num`)되기 이전임

---

</br>

# 핵심 개념

## Lexical Scope

- 코드를 작성할 때 결정되는 변수의 유효범위
  (코드가 어디서 실행되며 주변에 어떠한 코드가 있는지를 뜻함)

- 렉시컬 스코프는 `코드의 문맥`이라고 보면 되는데, 이를 구현한 것이 `execution context`임
  (모든 코드는 실행 컨텍스트에서 평가되고 실행됨)

```js
let num = 7;
if (1) {
  // ← 이 중괄호 { }가 새로운 블록을 만듦
  console.log(num);
  let num = 10;
}
```

### Lexical Scope가 생성되는 이유

- `{ }` 중괄호를 만나면 JS Engine은 자동으로 새로운 스코프를 생성한다.<br/>
  -> 이는 변수들을 격리시켜 관리하기 위함이다.

### Lexical Scope가 미치는 여향

- 내부 스코프는 외부 변수에서 접근 가능
- 외부 스코프는 내부 변수에 접근 불가능
- 같은 이름의 변수가 있다면 '가장 가까운 스코프'의 변수를 사용

## Block Scope

`let`과 `const`는 block level scope를 따른다.<br/>

중괄호 {}로 감싸진 영역(if문, for문 등) 안에서 선언된 변수는 그 블록 밖에서는 접근할 수 없으며, 반대로 블록 안에서는 독립적인 변수로 취급함.

## 호이스팅

변수 선언이 스코프 최상단으로 끌어올려진 것처럼 동작하는 것<br/>

- [Hoisting 개념 LINK](../hoisting/README.md)

### (호이스팅 심화) var, const, let

- _중요:_ `var`뿐만 아니라 `const`와 `let`도 호이스팅됨

- 다만, `var`와 달리 `let`은 `선언 단계`와 `초기화 단계`가 분리되어 있음<br/>

- 이해가 안가는 부분(하단)

스코프 진입 시 변수의 존재는 알지만(호이스팅 됨), 초기화 코드를 만날 때까지 메모리에 값을 할당하지 않습니다.

## TDZ (Temporal Dead Zone)

- `스코프의 시작 지점부터 변수 선언문이 나오기 전까지 구간`

- 이 구간에서 변수를 참고하려고 하면 `ReferenceError`가 발생함

- TDZ 진행 단계

1. 블록 진입(`{`): 내부 변수 `num`의 스코프가 시작됨 (TDZ 시작). 외부 변수 `num = 7`은 가려짐

2. `console.log(num)`: 아직 `num`이 초기화되지 않음 (TDZ 내부) -> `에러 발생!`

3. `let num = 10;`: 변수 `num`이 선언 및 초기화됨 (TDZ 종료)
   -> 이 줄 이후부터는 `num`을 안전하게 사용할 수 있음

# 코드 해석

```js
let num = 7; // 전역(혹은 상위)스코프의 num

if (true) {
  // <--- 여기부터 블록 스코프 시작
  // 엔진: "어? 밑에 'let num'이 있네? 이 블록에서 'num'는 내부 변수다. 호이스팅하자."
  // 엔진: "하지만 아직 초기화는 안 했으니 접근하면 에러를 낼 거야." (TDZ 시작)

  console.log(num); // [에러 발생!] TDZ 구간에서 num을 호출했음.
  // 외부의 num(7)가 아니라, 초기화되지 않은 내부 num을 참조하려다 실패.

  let num = 10; // <--- 여기서부터 TDZ 끝. 이제 num은 10임.
}
```
